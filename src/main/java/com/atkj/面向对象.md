# 面向对象

## 简单工厂

创建型，关注对象的创建过程

![截屏2023-12-29 01.32.52](/Users/mojie/Library/Application Support/typora-user-images/截屏2023-12-29 01.32.52.png)

## 原型模式

浅克隆和深克隆

一个类包含一些成员对象

## 适配器模式

结构型设计模式：在不同的环境，使用不同的方式将类和对象进行组合。

单个类的作用是有限的，系统中很多任务的完成需要多个类相互协作，因此需要把这些类进行组合

---

---

## UML

### 类图

![截屏2024-01-05 16.57.40](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 16.57.40.png)

![截屏2024-01-05 16.58.47](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 16.58.47.png)



### 类之间的关系

1. 关联关系

   一个类的对象作为另一个类的属性

   ![截屏2024-01-05 17.01.14](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 17.01.14.png)

   ![截屏2024-01-05 17.01.31](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 17.01.31.png)

   单向关联 双向关联 自关联 

   ![截屏2024-01-05 17.03.56](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 17.03.56.png)

   ![截屏2024-01-05 17.04.35](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 17.04.35.png)

   组合拆了就不行了 asoul

2. 依赖关系 

   某个类的方法使用另一个类的对象作为参数

   ![截屏2024-01-05 17.54.02](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 17.54.02.png)

3. 泛化关系/继承关系

   空心三角形实线  is a kind of

   Student is a kind of Person

   ![截屏2024-01-05 18.06.39](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 18.06.39.png)

4. 接口 

   空心三角形虚线



## 状态模式

`你中有我 我中有你`

行为型模式

一个对象的行为取决于他的状态。

比如人有两种状态，开心 伤心。

1. 两种状态可以相互转换
2. 不同状态下人的行为会不同

状态模式角色：

1. Context环境类 即有状态的对象
2. State 抽象状态类 
3. ConcreteState 具体状态类

![截屏2024-01-05 16.52.03](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 16.52.03.png)

环境类就是 论坛账号

状态

具体状态三个

根据状态的不同有不同的行为。

## 外观模式

![截屏2024-01-05 19.42.25](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 19.42.25.png)

三个关联关系 一连完事

![截屏2024-01-05 19.43.07](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 19.43.07.png)

## 工厂方法模式

抽象工厂 具体工厂 抽象产品 具体产品

海尔电视 tcl电视

海尔电视工厂 tcl电视工厂 

电视工厂

## 观察者模式

一个对象的状态改变会引起其他对象的状态改变

![截屏2024-01-05 19.49.18](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 19.49.18.png)

优：

1. 符合开闭原则，增加新的具体观察者无需修改原有代码
2. 在观察目标和观察者之间建立了一个抽象的耦合。观察目标不需要了解其具体观察者。
3. 支持广播通信，简化一对多的设计难度

缺：

1. 如果有很多观察者，通知要花很多时间
2. 观察者和目标之间如果有循环依赖，可能导致系统崩溃
3. 观察者只知道发生了变换，不知道发生了什么变换

实例：猫是狗和老鼠的观察目标，猫叫老鼠跑 猫叫狗叫

```java
// 抽象目标类

public abstract class MySubject {
  protected ArrayList observers = new ArrayList();
  
  // 注册方法 注册观察者
  public void attach(MyObserver observer) {
    observers.add(observer);
  }
  
  // 注销方法
  public void detach(MyObserver observer) {
    observers.remove(observer);
  }
  
  // 抽象通知方法 要把 通知传给所有观察者
  public abstract void cry();
}
```

```java
// 抽象观察者
public interface MyObserver {
	void response();// 抽象响应方法
}
```

```java
// 具体目标类cat
public class Cat extends MySubject 
{
  public void cry()
  {
    for(object objs : observers) {
      objs.response();
    }
  }
}
```

```java
// 具体观察者类
public class Mouse implements MyObserver 
{
  public void response()
  {
    sout("老鼠努力逃跑")
  }
}
```

``` java
// Client
public class Client
{
  psvm(){
    MySubject subject = new Cat();
    Myobserver obj1 = new Mouse();
    Myonserver obj2 = new Dog();
    subject.attach(obj1);
    subject.attach(obj2);
    
    subject.cry();
  }
}
```

## 单例模式

对于某些对象 只需要一个实例

![截屏2024-01-05 20.15.33](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 20.15.33.png)

优点：

1. 只存在一个对象，节约资源
2. 允许可变数目的实例，对单例模式进行扩展
3. 提供了对唯一实例的受控访问

缺点：

1. 没有抽象层，扩展有很大的问题
2. 责任过重，即使工厂角色，又是产品角色
3. java中实例对象长期不使用，会被自动销毁，这将导致对象状态的丢失

## 装饰模式

在不改变一个对象本身的基础上给对象增加额外的新行为 decorator pattern

角色：

1. 抽象构件
2. 具体构件
3. 抽象装饰类
4. 具体装饰类

![截屏2024-01-05 20.35.44](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 20.35.44.png)

实例 变形金刚 多重加密系统

有很多种加密方法，一开始有三种

可以对加密后的结果进行二次加密

怎么用的？

![截屏2024-01-05 20.46.05](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-05 20.46.05.png)



优点：

1. 装饰模式与继承的目的都是要扩展对象的功能，但是装饰模式更灵活
2. 使用不同装饰类的排列组合，能得到功能更强大的对象
3. 符合开闭原则，增加新的功能无需改变原有代码

缺点：

1. 会产生很多对象，增加系统的复杂度
2. 比继承更加容易出错，排错困难

抽象构件类

```java
public interface Transform
{
  // 要进行扩展的类 有基本的功能和要扩展的功能
  public void move();
}
```

// 具体构件类

```java
public final class Car implements Transform
{
  public Car(){}
  public void move(){
    sout("汽车移动")
  }
}
```

抽象装饰类

```java
public class Changer implements Transform
{
  private Tansform tansform;
  // 保留原来的car
  public Changer(Transform transform)
  {
    this.transform = transform;
  }
  
  // 实现transform接口
  public void move(){
    this.transform.move();
  }
}
```

具体装饰类

```java
public class Robot extends Changer{
  // 增加新的功能
  public Robot(Tansform transform) {
    // 父类构造函数
    super(transform);
    
  }
  
  // 新的功能
  public void say()
  {
    
  }
}
```

## 适配器模式

结构型设计模式

不兼容，通过一个新的设备使得原本不兼容的事物可以一起工作

优点：

1. 将目标类和适配器类解耦，无需修改原有代码
2. 增加了类的透明性和复用性
3. 有良好的灵活性和拓展性

缺点：

1. 对于不支持多重继承的语言来说，一次最多只能适配一个适配器类

实例：可以模仿各种动物的机器人 

机器人自己有动作，如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫。

```java
// 目标抽象类
public interface Robot
{
  public void cry();
  public void move();
}

// 适配者类
public class Dog
{
  public void wang(){
    sout("jiao");
  }
  public void run(){
    sout("pao");
  }
}

// 适配器类
public class DogAdapter extends Dog implements Robot
{
  // 实现接口的同时 可以调用父类的方法
}
```

## 代理模式

给某个对象提供一个代理，并由代理对象控制对原对象的引用

角色：

1. 真实主题角色 代理角色代表的真实对象
2. 代理主题角色 包含对真实主题的引用 代理
3. 抽象主题角色 声明了真实主题和代理主题的共同接口

实例：信用卡是银行的一个代理

实例：日志记录代理

某软件需要记录业务方法的调用日志，在不修改现有业务类的基础上为每个类提供一个日志记录代理类

优点：能够协调调用者和被调用者，降低系统耦合度

缺点：在客户端和真实主题角色之间新增了代理对象，可能导致请求处理变慢

```java
public class Proxy implements Subject
{
  private RealSubject realSubjects = new RealSubject();
  // 有点像AOP
  public void preRequest(){
    
  }
  public void request(){
    preRequest();
    realSubject.request();
    postRequest();
  }
  public void postrequest(){}
  
}
```

实例：一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖，修改自己的注册信息、修改自己的帖子等权限；游客只能看到别人发的帖子，没有其他权限。

```java
// 抽象主题角色
// 真实主题角色和代理主题角色的共同接口
public interface AbstractPerssion
{
  public void modifyUserInfo();
  public void viewNote();
  public void publishNote();
  public void modifyNote();
  public void setLevel(int level);
}

// 真实权限类 实现了所有接口里的方法


// 代理权限类 有真实权限类成员 并且维护一个 int role，
// 实现接口的时候如果有权限就调用真实权限类的方法
```

## 桥接模式

结构型

优点：

1. 分离抽象接口和实现部分，使得抽象和实现沿着各自的维度来变化
2. 提高了系统可扩展性
3. 实现细节对客户透明，用户在使用时不用关心实现

缺点：

1. `**模式的引入会增加系统的理解和设计难度`
2. `**模式的使用范围具有一定的局限性`

实例：模拟毛笔

提供大中小三种型号的画笔，能够绘制5种不同的颜色

```java
// 实现类接口 
public interface Color
{
  void paint(String penType,String name);
}
// 具体实现类
public class Red implements Color
{
  public void paint(String pentype String name)
  {
    sout("pentype" + "红色" + name);
  }
}

// 抽象类 
// 笔里面有颜色 笔是抽象类
public abstract class Pen
{
  protected Color color;
  public void setColor(Color color)
  {
    this.color = color;
    
  }
  public abstrct void draw(String name);
}

// 扩充抽象类
public class BigPen extends Pen
{
  public void draw(String name)
  {
    String penType = "big";
    this.color.paint(pentype,name);
  }
}

public class Client{
  psvm(){
    Color color = new Red();
    Pen pen = new BigPen();
    pen.setcolor(color);
    pen.draw();
  }
}
```



角色：笔里面有颜色 

pen抽象类 bigpen扩充抽象类

画画这件事最终是由color做的（实现类提供基本操作） color是实现类，red是具体实现类

跨平台播放器：

在不同的操作系统上播放多种格式的文件

os是抽象类 windows是扩展抽象类 video是实现类 wmv是具体实现类

## 享元模式

性能

通过共享技术实现对相同或相似对象的重用

角色：

1. 抽象享元类
2. 具体享元类
3. 非共享具体享元类
4. 享元工厂类

优点：

1. 极大减少内存中对象的数量
2. 外部状态相对独立而且不会影响其内部状态

缺点：

1. `享元模式的引入会增加系统的理解和设计难度`
2. `享元模式的使用范围具有一定的局限性`
3. 享元模式使得系统更加复杂

实例：共享网络设备

很多网络设备都是支持共享的，如交换机、集线器等。

```java
// 抽象享元类 networkdevice
public interface NetworkDevice
{
  public String getType();
  public void use();
}

// 具体享元类 交换机 可以共享
public class Switch implements NetworkDevice
{
  private String type;
  public Switch(String type)
  {
    this.type = type;
  }
  public String gettype()
  {
    return this.type;
  }
  public void use()
  {
    sout("switch" + type);
  }
}

// 具体享元类 集线器类
public class Hub implements NetworkDevice
{
  private String type;
  public Hub(String type)
  {
    this.type = type;
  }
  public String gettype(){
    return this.type;
  }
  
  public void use()
  {
    sout("Hub" + type)
  }
}

// 享元工厂类
public class DeviceFactory
{
  private ArrayList devices = new ArrayList();
  private int totalTerminal = 0;
  
  public DeviceFactory()
  {
    NetworkDevice nd1 = new Switch("cisco");
    device.add(nd1);
    NetworkDevice nd2 = new Hub("tp=link");
    device.add(nd2);
  }
  public NetworkDevice getNetworkDevice(String type)
  {
    
  }
}


```

## 组合模式

容器对象和叶子对象 

文件夹和文件

结构：

1. 抽象构件 包含所有子类共有行为的声明
2. 叶子构件Leaf 叶子构件没有子节点 实现接口，不能实现的抛出异常
3. 容器构件 实现

水果盘：**实例与解析12.3**

水果盘中有水果，大水果盘中有小水果盘 

对水果盘执行吃方法（遍历） 使用组合模式模拟

水果——叶子

水果盘——文件夹

```java
public abstract class MyElement
{
  public abstract void eat();
}
```

![截屏2024-01-06 00.30.05](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-06 00.30.05.png)

聚合关系

 ![截屏2024-01-06 00.31.29](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-06 00.31.29.png)

```java
// 抽象构件类
public abstract class MyElement
{
  public abstract void eat();
}

// 叶子构件类
public class Apple extends MyElement
{
  public void eat()
  {
    sout("吃苹果")
  }
}
public class Plate extends MyElement
{
  private ArrayList list = new ArrayList();
  public void add(MyElement element)
  {
    list.add(element);
  }
  public void remove(MyElemnt element)
  {
    list.remove(element);
  }
  public void eat()
  {
    for(Object object:list) 
    {
     (MyElement)object.eat();
    }
  }
}
```

## 中介者模式

两种qq聊天方式，第一种是用户与用户直接聊天，第二种是通过QQ群聊天，群的作用就是将发送者所发送的信息转发给每一个接收者用户。

![截屏2024-01-06 01.00.52](/Users/mojie/Library/Application Support/typora-user-images/截屏2024-01-06 01.00.52.png)

1. 抽象中介者 

   定义一个接口，该接口用于各同事对象之间的通信

2. 具体中介者

3. 抽象同事类

4. 具体同事类

实例：虚拟聊天室，普通会员可以发文本消息，钻石会员可以发文本消息和图片消息。该聊天室可以对不雅字符进行过滤

```java
// 抽象中介者
public abstract class AbstractChatroom
{
  public abstract void register(Member);
  public abstract sendText(string message);
  public abstract void sendImage(String image);
}

// 抽象同事类
public abstract class Member
{
  protected AbstractChatroom chatroom;
  protected String name;
  
  public Member(String name)
  {
    this.name = name;
  }
  
  public abstract void sendText(String text);
  public abstract sendImage(string image);
  public void receiveText()
  {
    
  }
  public void receiveImage()
  {
    
	}
  
  // 具体中介者 具体聊天室
  
}
```

